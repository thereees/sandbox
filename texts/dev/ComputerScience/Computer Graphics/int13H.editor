# header 1
int 13H

# paragraph

In the good old days of Computer Graphics all developers had access tho a contiguous memory array and writing a pixel as as simple as just MOVing a value to memory. Then came the "layers". Windows, DirectX, OpenGL etc... and the contiguous memory vanished. But we can bring it back!

Off course I am being a little bit overdramatic. We can still do this in theses abstractions. And we ARE going to do this here in webGL + WASM.

But first, let us reminder ourselves how things used to work:

# code c
#include <go32.h>
#include <sys/farptr.h>

void putpixel_13h(int x, int y, int color)
{
    _farpokeb(_dos_ds, 0xA0000+y*320+x, color);
}
#####
# link p 1

http://www.delorie.com/djgpp/doc/ug/graphics/vga.html

# paragraph

This function will write pixel "color" in the "x" and "y" coordinates. The "0xA0000" is the standard address to access the VGA. In this case the function is hardcoded to 320x240. The important part is how to map from (x,y) to a contiguous memory array: using the function (x,y) -> start+(y*width)+x.

# quotelink

The video memory of the VGA is mapped to the PC's memory via a window in the range between segments 0xA0000 and 0xBFFFF in the PC's real mode address space (A000:0000 and B000:FFFF in segment:offset notation). Typically, these starting segments are:
0xA0000 for EGA/VGA graphics modes (64 KB)

https://en.wikipedia.org/wiki/Video_Graphics_Array

# paragraph

To good news is that we can easily do this in every framework that exists: win32, GDI, DirectX, OpenGL, SDL etc... you name it, and we can do it. To prove, we are goind to do it inside webGL. Allowing us to write "directly" to the screen using Javascript and WASM. "Directly" was in quotes because, in reality, is as "directly" as possible. But the feeling is exactly the same.

So let us begin!

# header 2

Setup

# paragraph

Our first step is the start out HTML page and initialize WebGL. This tutorial does not intend to be an introduction to WebGL/OpenGL and/or 3D development, altough we will explain everything. WebGL is acessed throught the "canvas" element. We just need to get the "webgl" context. Much simpler than in Windows/Linux environment.

# code html
<!DOCTYPE html>
<html>
<body>
    <canvas id="screen" width="320" height="240"></canvas>
    <script>
        var canvas = document.getElementsById("screen");
        var gl = canvas.getContext("webgl");
    </script>
</body>
</html>
#####
# paragraph

What we need to do now is not very intuitive. WebGL/OpenGL is aimed to drawing geometric figures, specially in 3D. What we want is a contiguous memory address to write our pixels. The easist way to achieve this in WebGL is:

# ol

Draw a rectangle that fills 100% of the screen;
Apply a texture that is exactly the same size as the screen to this rectangle;
Get the address of this texture;
Write what we want to draw in this address;
Update the texture;
Update the screen;

# paragraph

Steps 1,2,3 are setup and done only once in the initialization. Steps 5, 6 are generic. And step 4 is our code. What we will do is pass the texture address to a function that will ignore everything and just write to this memory.

# header 2

Step 1 - Rectangle

# paragraph

WebGL/OpenGL aim is much complex cases than drawing rects. So it looks like a lot of work to draw a simple rectangle. But remember that we need to send everything to the video card, and then ask the WebGL/OpenGL/Video Card to draw what we created. So that is what we need to do:

# ol

specify each vertice in a rectangle (there are four of them);
specify the triangles that forms the rectangle (WebGL/OpenGL love triangles) (there are two triangles);
draw them.

# paragraph

The vertices are easy to understand. A rectangle contains four vertices. WebGL starts with the point (0,0) right in the middle of the screen with the top-left pixel being the (-1,-1) and the bottom right being (1,1).

The triangles are specified by three integers that points to the vertice array.

WebGL/OpenGL works always like this:

# ol

Create an object. You receive a integer that "points" to the object (remember the object lives inside the Video Card);
Activate the buffer (tells WebGL/OpenGL that you will modify this object)

# paragraph

We do not need to return the array with vertices and indices, because we copyed them to the video card. That is what the "verticesBuffer" and "indicesBuffer" mean.

# code javascript
function createRectangle(){
    // Vertices
    var positions = new Float32Array([
        -1.0, -1.0,
        +1.0, -1.0,
        +1.0, +1.0,
        -1.0, +1.0,
    ]);
    var verticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    // Triangles
    var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    var indicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    return [verticesBuffer, indicesBuffer];
}

function draw(verticiesBuffer, indicesBuffer) {    
    gl.bindBuffer(gl.ARRAY_BUFFER, verticiesBuffer);
    gl.vertexAttribPointer(a_coords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_coords);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}
#####
# paragraph

The draw code contains some mysterious variables, that we have not seen yet, but the general "geist" of the code is obvious. Activate the vertex buffer, the index buffer and them webGL to use them. This will give us a rectangle filling the entire screen.

# header 2

Step 1 - Apply Texture

# paragraph

So our next step is to apply the texture. To apply a texture you need two things. A texture, a image and associate to each vertex a coordinate in the image. If you say that vertex 0 has texture coordinates (0,0) that means that when drawing that vertex, you draw the first pixel of the image. WebGL will interpolate the value between vertices. So our function now is:

We will start with the second step. The texture coordinates creation.

# code javascript
function createRectangle(){
    // Vertices
    var positions = new Float32Array([
        -1.0, -1.0,
        +1.0, -1.0,
        +1.0, +1.0,
        -1.0, +1.0,
    ]);
    var verticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    // Texture
    var texCoords = new Float32Array([
        +0.0, +0.0,
        +1.0, +0.0,
        +1.0, +1.0,
        +0.0, +1.0,
    ]);
    var texCoordsBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

    // Triangles
    var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
    var indicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    return [verticesBuffer, texCoordsBuffer, indicesBuffer];
}

function draw(verticiesBuffer, texCoordBuffer, indicesBuffer) {
    // activate vertices
    gl.bindBuffer(gl.ARRAY_BUFFER, verticiesBuffer);
    gl.vertexAttribPointer(a_coords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_coords);

    // activate texture
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.vertexAttribPointer(a_texcoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texcoords);

    // draw triangles
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
}
#####
# paragraph

Now we create the texture. Normally one would read an image file like .bmp, .png etc... We will actually create an empty image. Because we want a way to write pixels and send to the video card. The way to do this is very simple. This function is going to receive the buffer, instead of creating, because we will use an existing buffer later on.

There are a lot of parameters and details that we will skip here at this moment. The important thing here is how we create the texture and send the "buffer" to the video card and the texture pixels. We will do something very similar later on to update the texture.

# code javascript
function createEmptyTexture(width, height, buffer) {
    var pixels = new Uint8Array(buffer);     

    var texture = gl.createTexture();        
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

    return [texture, pixels];
}

function draw(texture, verticiesBuffer, texCoordBuffer, indicesBuffer) {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // ... same as before
}
#####
# paragraph

Now our rectangle has a texture. Given that out texture is empty, our rectangle is also empty. That is ok. because we are about to write something to it.